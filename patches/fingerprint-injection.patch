diff --git a/browser/app/moz.build b/browser/app/moz.build
index 7a94cc4f90..9d3c5a5364 100644
--- a/browser/app/moz.build
+++ b/browser/app/moz.build
@@ -182,3 +182,6 @@ if CONFIG["MOZ_ASAN"] or CONFIG["MOZ_DEBUG"]:
     WINCONSOLE = True
 else:
     WINCONSOLE = False
+
+# DOM Mask
+LOCAL_INCLUDES += ["/camoucfg"]
diff --git a/dom/base/ChromeUtils.cpp b/dom/base/ChromeUtils.cpp
index 5c4a99e81a..0899fd1ad0 100644
--- a/dom/base/ChromeUtils.cpp
+++ b/dom/base/ChromeUtils.cpp
@@ -5,6 +5,14 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

 #include "ChromeUtils.h"
+#include "MaskConfig.hpp"
+#include "MouseTrajectories.hpp"
+#include "BatteryManager.h"
+
+#include <algorithm>
+#include <cmath>
+#include <optional>
+#include <vector>

 #include "JSOracleParent.h"
 #include "ThirdPartyUtil.h"
@@ -2481,6 +2489,25 @@ bool ChromeUtils::IsDarkBackground(GlobalObject&, Element& aElement) {
   return nsNativeTheme::IsDarkBackground(f);
 }

+/* static */
+void ChromeUtils::CamouDebug(GlobalObject& aGlobal, const nsAString& aVarName) {
+  if (auto value = MaskConfig::GetBool("debug");
+      value.has_value() && !value.value()) {
+    return;
+  }
+  NS_ConvertUTF16toUTF8 utf8VarName(aVarName);
+  printf_stderr("DEBUG: %s\\n", utf8VarName.get());
+}
+
+/* static */
+bool ChromeUtils::IsCamouDebug(GlobalObject& aGlobal) {
+  if (auto value = MaskConfig::GetBool("debug");
+      value.has_value() && value.value()) {
+    return true;
+  }
+  return false;
+}
+
 double ChromeUtils::DateNow(GlobalObject&) { return JS_Now() / 1000.0; }

 /* static */
@@ -2512,6 +2539,77 @@ void ChromeUtils::GetAllPossibleUtilityActorNames(GlobalObject& aGlobal,
   }
 }

+/* static */
+int32_t ChromeUtils::CamouGetInt(GlobalObject& aGlobal,
+                                 const nsAString& aVarName) {
+  NS_ConvertUTF16toUTF8 utf8VarName(aVarName);
+  if (auto value = MaskConfig::GetInt32(utf8VarName.get())) {
+    return value.value();
+  }
+  return 0;
+}
+
+/* static */
+double ChromeUtils::CamouGetDouble(GlobalObject& aGlobal,
+                                   const nsAString& aVarName,
+                                   double aDefaultValue) {
+  NS_ConvertUTF16toUTF8 utf8VarName(aVarName);
+  if (auto value = MaskConfig::GetDouble(utf8VarName.get())) {
+    return value.value();
+  }
+  return aDefaultValue;
+}
+
+/* static */
+bool ChromeUtils::CamouGetBool(GlobalObject& aGlobal, const nsAString& aVarName,
+                               bool aDefaultValue) {
+  NS_ConvertUTF16toUTF8 utf8VarName(aVarName);
+  if (auto value = MaskConfig::GetBool(utf8VarName.get())) {
+    return value.value();
+  }
+  return aDefaultValue;
+}
+
+/* static */
+void ChromeUtils::CamouGetString(GlobalObject& aGlobal,
+                                 const nsAString& aVarName,
+                                 nsAString& aRetVal) {
+  NS_ConvertUTF16toUTF8 utf8VarName(aVarName);
+  if (auto value = MaskConfig::GetString(utf8VarName.get())) {
+    aRetVal.Assign(NS_ConvertUTF8toUTF16(value.value()));
+  } else {
+    aRetVal.Truncate();
+  }
+}
+
+/* static */
+void ChromeUtils::CamouGetStringList(GlobalObject& aGlobal,
+                                     const nsAString& aVarName,
+                                     nsTArray<nsString>& aRetVal) {
+  NS_ConvertUTF16toUTF8 utf8VarName(aVarName);
+  if (auto values = MaskConfig::GetStringList(utf8VarName.get());
+      !values.empty()) {
+    aRetVal.Clear();
+    for (const auto& str : values) {
+      aRetVal.AppendElement(NS_ConvertUTF8toUTF16(str));
+    }
+    return;
+  }
+  aRetVal.Clear();
+}
+
+/* static */
+void ChromeUtils::CamouGetMouseTrajectory(GlobalObject& aGlobal, long aFromX,
+                                          long aFromY, long aToX, long aToY,
+                                          nsTArray<int32_t>& aPoints) {
+  HumanizeMouseTrajectory trajectory(std::make_pair(aFromX, aFromY),
+                                     std::make_pair(aToX, aToY));
+  std::vector<int> flattenedPoints = trajectory.getPoints();
+
+  aPoints.Clear();
+  aPoints.AppendElements(flattenedPoints.data(), flattenedPoints.size());
+}
+
 /* static */
 bool ChromeUtils::ShouldResistFingerprinting(
     GlobalObject& aGlobal, JSRFPTarget aTarget,
diff --git a/dom/base/ChromeUtils.h b/dom/base/ChromeUtils.h
index ef232208b0..fa63e8ef4d 100644
--- a/dom/base/ChromeUtils.h
+++ b/dom/base/ChromeUtils.h
@@ -313,6 +313,10 @@ class ChromeUtils {

   static bool IsDarkBackground(GlobalObject&, Element&);

+  static void CamouDebug(GlobalObject& aGlobal, const nsAString& aVarName);
+
+  static bool IsCamouDebug(GlobalObject& aGlobal);
+
   static double DateNow(GlobalObject&);

   static double Now(GlobalObject&);
@@ -324,6 +328,25 @@ class ChromeUtils {
   static void GetAllPossibleUtilityActorNames(GlobalObject& aGlobal,
                                               nsTArray<nsCString>& aNames);

+  static int32_t CamouGetInt(GlobalObject& aGlobal, const nsAString& aVarName);
+
+  static double CamouGetDouble(GlobalObject& aGlobal, const nsAString& aVarName,
+                               double aDefaultValue);
+
+  static bool CamouGetBool(GlobalObject& aGlobal, const nsAString& aVarName,
+                           bool aDefaultValue);
+
+  static void CamouGetString(GlobalObject& aGlobal, const nsAString& aVarName,
+                             nsAString& aRetVal);
+
+  static void CamouGetStringList(GlobalObject& aGlobal,
+                                 const nsAString& aVarName,
+                                 nsTArray<nsString>& aRetVal);
+
+  static void CamouGetMouseTrajectory(GlobalObject& aGlobal, long aFromX,
+                                      long aFromY, long aToX, long aToY,
+                                      nsTArray<int32_t>& aPoints);
+
   static bool ShouldResistFingerprinting(
       GlobalObject& aGlobal, JSRFPTarget aTarget,
       nsIRFPTargetSetIDL* aOverriddenFingerprintingSettings,
diff --git a/dom/base/Element.cpp b/dom/base/Element.cpp
index b74fdb90cc..6e2af15d2b 100644
--- a/dom/base/Element.cpp
+++ b/dom/base/Element.cpp
@@ -11,6 +11,7 @@
  */

 #include "mozilla/dom/Element.h"
+#include "MaskConfig.hpp"

 #include <inttypes.h>

@@ -1019,6 +1020,18 @@ nsRect Element::GetClientAreaRect() {
   Document* doc = OwnerDoc();
   nsPresContext* presContext = doc->GetPresContext();

+  if (doc->GetBodyElement() == this) {
+    if (auto conf = MaskConfig::GetInt32Rect(
+            "document.body.clientLeft", "document.body.clientTop",
+            "document.body.clientWidth", "document.body.clientHeight")) {
+      if (conf.has_value()) {
+        auto values = conf.value();
+        return nsRect(values[0] * 60, values[1] * 60, values[2] * 60,
+                      values[3] * 60);
+      }
+    }
+  }
+
   // We can avoid a layout flush if this is the scrolling element of the
   // document, we have overlay scrollbars, and we aren't embedded in another
   // document
diff --git a/dom/base/Navigator.cpp b/dom/base/Navigator.cpp
index 233e613886..4fea7b3c51 100644
--- a/dom/base/Navigator.cpp
+++ b/dom/base/Navigator.cpp
@@ -6,6 +6,7 @@

 // Needs to be first.
 #include "Navigator.h"
+#include "MaskConfig.hpp"

 #include "Geolocation.h"
 #include "base/basictypes.h"
@@ -262,6 +263,10 @@ void Navigator::Invalidate() {

 void Navigator::GetUserAgent(nsAString& aUserAgent, CallerType aCallerType,
                              ErrorResult& aRv) const {
+  if (auto value = MaskConfig::GetString("navigator.userAgent")) {
+    aUserAgent.Assign(NS_ConvertUTF8toUTF16(value.value()));
+    return;
+  }
   nsCOMPtr<nsPIDOMWindowInner> window;

   if (mWindow) {
@@ -288,6 +293,10 @@ void Navigator::GetUserAgent(nsAString& aUserAgent, CallerType aCallerType,
 }

 void Navigator::GetAppCodeName(nsAString& aAppCodeName, ErrorResult& aRv) {
+  if (auto value = MaskConfig::GetString("navigator.appCodeName")) {
+    aAppCodeName.Assign(NS_ConvertUTF8toUTF16(value.value()));
+    return;
+  }
   nsresult rv;

   nsCOMPtr<nsIHttpProtocolHandler> service(
@@ -309,6 +318,10 @@ void Navigator::GetAppCodeName(nsAString& aAppCodeName, ErrorResult& aRv) {

 void Navigator::GetAppVersion(nsAString& aAppVersion, CallerType aCallerType,
                               ErrorResult& aRv) const {
+  if (auto value = MaskConfig::GetString("navigator.appVersion")) {
+    aAppVersion.Assign(NS_ConvertUTF8toUTF16(value.value()));
+    return;
+  }
   nsCOMPtr<Document> doc = mWindow->GetExtantDoc();

   nsresult rv = GetAppVersion(
@@ -320,6 +333,10 @@ void Navigator::GetAppVersion(nsAString& aAppVersion, CallerType aCallerType,
 }

 void Navigator::GetAppName(nsAString& aAppName) const {
+  if (auto value = MaskConfig::GetString("navigator.appName")) {
+    aAppName.Assign(NS_ConvertUTF8toUTF16(value.value()));
+    return;
+  }
   aAppName.AssignLiteral("Netscape");
 }

@@ -344,6 +361,15 @@ void Navigator::GetAcceptLanguages(nsTArray<nsString>& aLanguages) {

   aLanguages.Clear();

+  if (std::vector<std::string> maskValues =
+          MaskConfig::GetStringList("navigator.languages");
+      !maskValues.empty()) {
+    for (const auto& lang : maskValues) {
+      aLanguages.AppendElement(NS_ConvertUTF8toUTF16(lang));
+    }
+    return;
+  }
+
   // E.g. "de-de, en-us,en".
   nsAutoString acceptLang;
   Preferences::GetLocalizedString("intl.accept_languages", acceptLang);
@@ -391,6 +417,10 @@ void Navigator::GetAcceptLanguages(nsTArray<nsString>& aLanguages) {
  * Full details above in GetAcceptLanguages.
  */
 void Navigator::GetLanguage(nsAString& aLanguage) {
+  if (auto value = MaskConfig::GetString("navigator.language")) {
+    aLanguage.Assign(NS_ConvertUTF8toUTF16(value.value()));
+    return;
+  }
   nsTArray<nsString> languages;
   GetLanguages(languages);
   MOZ_ASSERT(languages.Length() >= 1);
@@ -408,6 +438,10 @@ void Navigator::GetLanguages(nsTArray<nsString>& aLanguages) {

 void Navigator::GetPlatform(nsAString& aPlatform, CallerType aCallerType,
                             ErrorResult& aRv) const {
+  if (auto value = MaskConfig::GetString("navigator.platform")) {
+    aPlatform.Assign(NS_ConvertUTF8toUTF16(value.value()));
+    return;
+  }
   if (mWindow) {
     BrowsingContext* bc = mWindow->GetBrowsingContext();
     nsString customPlatform;
@@ -434,6 +468,10 @@ void Navigator::GetPlatform(nsAString& aPlatform, CallerType aCallerType,
 void Navigator::GetOscpu(nsAString& aOSCPU, CallerType aCallerType,
                          ErrorResult& aRv) const {
   if (aCallerType != CallerType::System) {
+    if (auto value = MaskConfig::GetString("navigator.oscpu")) {
+      aOSCPU.Assign(NS_ConvertUTF8toUTF16(value.value()));
+      return;
+    }
     // If fingerprinting resistance is on, we will spoof this value. See
     // nsRFPService.h for details about spoofed values.
     if (nsContentUtils::ShouldResistFingerprinting(GetDocShell(),
@@ -473,10 +511,18 @@ void Navigator::GetVendor(nsAString& aVendor) { aVendor.Truncate(); }
 void Navigator::GetVendorSub(nsAString& aVendorSub) { aVendorSub.Truncate(); }

 void Navigator::GetProduct(nsAString& aProduct) {
+  if (auto value = MaskConfig::GetString("navigator.product")) {
+    aProduct.Assign(NS_ConvertUTF8toUTF16(value.value()));
+    return;
+  }
   aProduct.AssignLiteral("Gecko");
 }

 void Navigator::GetProductSub(nsAString& aProductSub) {
+  if (auto value = MaskConfig::GetString("navigator.productSub")) {
+    aProductSub.Assign(NS_ConvertUTF8toUTF16(value.value()));
+    return;
+  }
   // Legacy build date hardcoded for backward compatibility (bug 776376)
   aProductSub.AssignLiteral(LEGACY_UA_GECKO_TRAIL);
 }
@@ -502,7 +548,12 @@ nsPluginArray* Navigator::GetPlugins(ErrorResult& aRv) {
   return mPlugins;
 }

-bool Navigator::PdfViewerEnabled() { return !StaticPrefs::pdfjs_disabled(); }
+bool Navigator::PdfViewerEnabled() {
+  if (auto value = MaskConfig::GetBool("pdfViewerEnabled"); value.has_value()) {
+    return value.value();
+  }
+  return !StaticPrefs::pdfjs_disabled();
+}

 Permissions* Navigator::GetPermissions(ErrorResult& aRv) {
   if (!mWindow) {
@@ -528,6 +579,10 @@ StorageManager* Navigator::Storage() {
 }

 bool Navigator::CookieEnabled() {
+  if (auto value = MaskConfig::GetBool("navigator.cookieEnabled");
+      value.has_value()) {
+    return value.value();
+  }
   // Check whether an exception overrides the global cookie behavior
   // Note that the code for getting the URI here matches that in
   // nsHTMLDocument::SetCookie.
@@ -574,6 +629,9 @@ bool Navigator::CookieEnabled() {
 }

 bool Navigator::OnLine() {
+  if (auto value = MaskConfig::GetBool("navigator.onLine"); value.has_value()) {
+    return value.value();
+  }
   if (nsContentUtils::ShouldResistFingerprinting(
           GetDocShell(), RFPTarget::NetworkConnection)) {
     return true;
@@ -593,6 +651,10 @@ bool Navigator::OnLine() {
 void Navigator::GetBuildID(nsAString& aBuildID, CallerType aCallerType,
                            ErrorResult& aRv) const {
   if (aCallerType != CallerType::System) {
+    if (auto value = MaskConfig::GetString("navigator.buildID")) {
+      aBuildID.Assign(NS_ConvertUTF8toUTF16(value.value()));
+      return;
+    }
     // If fingerprinting resistance is on, we will spoof this value. See
     // nsRFPService.h for details about spoofed values.
     if (nsContentUtils::ShouldResistFingerprinting(
@@ -649,6 +711,10 @@ void Navigator::GetBuildID(nsAString& aBuildID, CallerType aCallerType,
 }

 void Navigator::GetDoNotTrack(nsAString& aResult) {
+  if (auto value = MaskConfig::GetString("navigator.doNotTrack")) {
+    aResult.Assign(NS_ConvertUTF8toUTF16(value.value()));
+    return;
+  }
   if (StaticPrefs::privacy_donottrackheader_enabled()) {
     aResult.AssignLiteral("1");
   } else {
@@ -657,6 +723,10 @@ void Navigator::GetDoNotTrack(nsAString& aResult) {
 }

 bool Navigator::GlobalPrivacyControl() {
+  if (auto value = MaskConfig::GetBool("navigator.globalPrivacyControl");
+      value.has_value()) {
+    return value.value();
+  }
   bool gpcStatus = StaticPrefs::privacy_globalprivacycontrol_enabled();
   if (!gpcStatus) {
     nsCOMPtr<nsILoadContext> loadContext = do_GetInterface(mWindow);
@@ -668,6 +738,9 @@ bool Navigator::GlobalPrivacyControl() {
 }

 uint64_t Navigator::HardwareConcurrency() {
+  if (auto value = MaskConfig::GetUint64("navigator.hardwareConcurrency")) {
+    return value.value();
+  }
   workerinternals::RuntimeService* rts =
       workerinternals::RuntimeService::GetOrCreateService();
   if (!rts) {
@@ -868,6 +941,9 @@ bool Navigator::Vibrate(const nsTArray<uint32_t>& aPattern) {
 //*****************************************************************************

 uint32_t Navigator::MaxTouchPoints(CallerType aCallerType) {
+  if (auto value = MaskConfig::GetUint32("navigator.maxTouchPoints")) {
+    return value.value();
+  }
   nsIDocShell* docshell = GetDocShell();
   BrowsingContext* bc = docshell ? docshell->GetBrowsingContext() : nullptr;

@@ -1405,6 +1481,18 @@ Promise* Navigator::GetBattery(ErrorResult& aRv) {
     return nullptr;
   }

+  if (auto enabled = MaskConfig::GetBool("battery");
+      enabled.has_value() && !enabled.value()) {
+    RefPtr<Promise> batteryPromise = Promise::Create(mWindow->AsGlobal(), aRv);
+    if (NS_WARN_IF(aRv.Failed())) {
+      return nullptr;
+    }
+    batteryPromise->MaybeRejectWithNotSupportedError(
+        "Battery API disabled via Camoufox configuration"_ns);
+    mBatteryPromise = batteryPromise;
+    return mBatteryPromise;
+  }
+
   RefPtr<Promise> batteryPromise = Promise::Create(mWindow->AsGlobal(), aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
diff --git a/dom/base/moz.build b/dom/base/moz.build
index aab9201540..6be22c7965 100644
--- a/dom/base/moz.build
+++ b/dom/base/moz.build
@@ -650,3 +650,6 @@ GeneratedFile(
         "/servo/components/style/properties/counted_unknown_properties.py",
     ],
 )
+
+# DOM Mask
+LOCAL_INCLUDES += ["/camoucfg"]
diff --git a/dom/base/nsGlobalWindowInner.cpp b/dom/base/nsGlobalWindowInner.cpp
index c9f5763aa8..c59f79f4cf 100644
--- a/dom/base/nsGlobalWindowInner.cpp
+++ b/dom/base/nsGlobalWindowInner.cpp
@@ -5,6 +5,7 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

 #include "nsGlobalWindowInner.h"
+#include "MaskConfig.hpp"

 #include <inttypes.h>
 #include <stdio.h>
@@ -3446,6 +3447,9 @@ void nsGlobalWindowInner::SetName(const nsAString& aName,
 }

 double nsGlobalWindowInner::GetInnerWidth(ErrorResult& aError) {
+  if (auto value = MaskConfig::GetDouble("window.innerWidth")) {
+    return value.value();
+  }
   FORWARD_TO_OUTER_OR_THROW(GetInnerWidthOuter, (aError), aError, 0);
 }

@@ -3457,6 +3461,9 @@ nsresult nsGlobalWindowInner::GetInnerWidth(double* aWidth) {
 }

 double nsGlobalWindowInner::GetInnerHeight(ErrorResult& aError) {
+  if (auto value = MaskConfig::GetDouble("window.innerHeight")) {
+    return value.value();
+  }
   // We ignore aCallerType; we only have that argument because some other things
   // called by GetReplaceableWindowCoord need it.  If this ever changes, fix
   //   nsresult nsGlobalWindowInner::GetInnerHeight(double* aInnerWidth)
@@ -3473,12 +3480,18 @@ nsresult nsGlobalWindowInner::GetInnerHeight(double* aHeight) {

 int32_t nsGlobalWindowInner::GetOuterWidth(CallerType aCallerType,
                                            ErrorResult& aError) {
+  if (auto value = MaskConfig::GetInt32("window.outerWidth")) {
+    return value.value();
+  }
   FORWARD_TO_OUTER_OR_THROW(GetOuterWidthOuter, (aCallerType, aError), aError,
                             0);
 }

 int32_t nsGlobalWindowInner::GetOuterHeight(CallerType aCallerType,
                                             ErrorResult& aError) {
+  if (auto value = MaskConfig::GetInt32("window.outerHeight")) {
+    return value.value();
+  }
   FORWARD_TO_OUTER_OR_THROW(GetOuterHeightOuter, (aCallerType, aError), aError,
                             0);
 }
@@ -3493,11 +3506,17 @@ double nsGlobalWindowInner::ScreenEdgeSlopY() const {

 int32_t nsGlobalWindowInner::GetScreenX(CallerType aCallerType,
                                         ErrorResult& aError) {
+  if (auto value = MaskConfig::GetInt32("window.screenX")) {
+    return value.value();
+  }
   FORWARD_TO_OUTER_OR_THROW(GetScreenXOuter, (aCallerType, aError), aError, 0);
 }

 int32_t nsGlobalWindowInner::GetScreenY(CallerType aCallerType,
                                         ErrorResult& aError) {
+  if (auto value = MaskConfig::GetInt32("window.screenY")) {
+    return value.value();
+  }
   FORWARD_TO_OUTER_OR_THROW(GetScreenYOuter, (aCallerType, aError), aError, 0);
 }

@@ -3531,6 +3550,9 @@ static nsPresContext* GetPresContextForRatio(Document* aDoc) {
 double nsGlobalWindowInner::GetDevicePixelRatio(CallerType aCallerType,
                                                 ErrorResult& aError) {
   ENSURE_ACTIVE_DOCUMENT(aError, 0.0);
+  if (auto value = MaskConfig::GetDouble("window.devicePixelRatio")) {
+    return value.value();
+  }

   RefPtr<nsPresContext> presContext = GetPresContextForRatio(mDoc);
   if (NS_WARN_IF(!presContext)) {
@@ -3601,26 +3623,44 @@ already_AddRefed<MediaQueryList> nsGlobalWindowInner::MatchMedia(
 }

 int32_t nsGlobalWindowInner::GetScrollMinX(ErrorResult& aError) {
+  if (auto value = MaskConfig::GetInt32("window.scrollMinX")) {
+    return value.value();
+  }
   FORWARD_TO_OUTER_OR_THROW(GetScrollBoundaryOuter, (eSideLeft), aError, 0);
 }

 int32_t nsGlobalWindowInner::GetScrollMinY(ErrorResult& aError) {
+  if (auto value = MaskConfig::GetInt32("window.scrollMinY")) {
+    return value.value();
+  }
   FORWARD_TO_OUTER_OR_THROW(GetScrollBoundaryOuter, (eSideTop), aError, 0);
 }

 int32_t nsGlobalWindowInner::GetScrollMaxX(ErrorResult& aError) {
+  if (auto value = MaskConfig::GetInt32("window.scrollMaxX")) {
+    return value.value();
+  }
   FORWARD_TO_OUTER_OR_THROW(GetScrollBoundaryOuter, (eSideRight), aError, 0);
 }

 int32_t nsGlobalWindowInner::GetScrollMaxY(ErrorResult& aError) {
+  if (auto value = MaskConfig::GetInt32("window.scrollMaxY")) {
+    return value.value();
+  }
   FORWARD_TO_OUTER_OR_THROW(GetScrollBoundaryOuter, (eSideBottom), aError, 0);
 }

 double nsGlobalWindowInner::GetScrollX(ErrorResult& aError) {
+  if (auto value = MaskConfig::GetDouble("screen.pageXOffset")) {
+    return value.value();
+  }
   FORWARD_TO_OUTER_OR_THROW(GetScrollXOuter, (), aError, 0);
 }

 double nsGlobalWindowInner::GetScrollY(ErrorResult& aError) {
+  if (auto value = MaskConfig::GetDouble("screen.pageYOffset")) {
+    return value.value();
+  }
   FORWARD_TO_OUTER_OR_THROW(GetScrollYOuter, (), aError, 0);
 }

diff --git a/dom/base/nsHistory.cpp b/dom/base/nsHistory.cpp
index e2fd8e6389..0aa32b1ff3 100644
--- a/dom/base/nsHistory.cpp
+++ b/dom/base/nsHistory.cpp
@@ -5,6 +5,7 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

 #include "nsHistory.h"
+#include "MaskConfig.hpp"

 #include "jsapi.h"
 #include "mozilla/RefPtr.h"
@@ -64,6 +65,9 @@ JSObject* nsHistory::WrapObject(JSContext* aCx,
 }

 uint32_t nsHistory::GetLength(ErrorResult& aRv) const {
+  if (auto value = MaskConfig::GetUint32("window.history.length")) {
+    return value.value();
+  }
   nsCOMPtr<nsPIDOMWindowInner> win(do_QueryReferent(mInnerWindow));
   if (!win || !win->HasActiveDocument()) {
     aRv.Throw(NS_ERROR_DOM_SECURITY_ERR);
diff --git a/dom/base/nsScreen.cpp b/dom/base/nsScreen.cpp
index 306ab35772..28cfbce927 100644
--- a/dom/base/nsScreen.cpp
+++ b/dom/base/nsScreen.cpp
@@ -5,6 +5,7 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

 #include "nsScreen.h"
+#include "MaskConfig.hpp"

 #include "mozilla/GeckoBindings.h"
 #include "mozilla/dom/Document.h"
@@ -40,6 +41,12 @@ NS_IMPL_CYCLE_COLLECTION_INHERITED(nsScreen, DOMEventTargetHelper,
                                    mScreenOrientation)

 int32_t nsScreen::PixelDepth() {
+  if (auto value = MaskConfig::GetUint32("screen.colorDepth")) {
+    return value.value();
+  }
+  if (auto value = MaskConfig::GetUint32("screen.pixelDepth")) {
+    return value.value();
+  }
   // Return 24 to prevent fingerprinting.
   if (ShouldResistFingerprinting(RFPTarget::ScreenPixelDepth)) {
     return 24;
@@ -89,6 +96,13 @@ CSSIntRect nsScreen::GetRect() {
 }

 CSSIntRect nsScreen::GetAvailRect() {
+  if (auto rect = MaskConfig::GetRect("screen.availLeft", "screen.availTop",
+                                      "screen.availWidth",
+                                      "screen.availHeight");
+      rect.has_value()) {
+    auto values = rect.value();
+    return {values[0], values[1], values[2], values[3]};
+  }
   // Return window inner rect to prevent fingerprinting.
   if (ShouldResistFingerprinting(RFPTarget::ScreenAvailRect)) {
     return GetTopWindowInnerRectForRFP();
diff --git a/dom/battery/BatteryManager.cpp b/dom/battery/BatteryManager.cpp
index 6322093fd9..b1eea5d7c6 100644
--- a/dom/battery/BatteryManager.cpp
+++ b/dom/battery/BatteryManager.cpp
@@ -5,6 +5,7 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

 #include "BatteryManager.h"
+#include "MaskConfig.hpp"

 #include <cmath>
 #include <limits>
@@ -13,10 +14,12 @@
 #include "mozilla/DOMEventTargetHelper.h"
 #include "mozilla/Hal.h"
 #include "mozilla/Preferences.h"
+#include "mozilla/Unused.h"
 #include "mozilla/dom/BatteryManagerBinding.h"
 #include "mozilla/dom/Document.h"
 #include "nsContentUtils.h"
 #include "nsGlobalWindowInner.h"
+#include "nsThreadUtils.h"

 /**
  * We have to use macros here because our leak analysis tool things we are
@@ -29,6 +32,8 @@

 namespace mozilla::dom::battery {

+StaticAutoPtr<nsTArray<BatteryManager*>> BatteryManager::sInstances;
+
 BatteryManager::BatteryManager(nsPIDOMWindowInner* aWindow)
     : DOMEventTargetHelper(aWindow),
       mLevel(kDefaultLevel),
@@ -42,9 +47,28 @@ void BatteryManager::Init() {
   hal::GetCurrentBatteryInformation(&batteryInfo);

   UpdateFromBatteryInfo(batteryInfo);
+
+  if (!sInstances) {
+    sInstances = new nsTArray<BatteryManager*>();
+  }
+
+  if (!sInstances->Contains(this)) {
+    sInstances->AppendElement(this);
+  }
+
+  UpdateLastOverrideState();
 }

-void BatteryManager::Shutdown() { hal::UnregisterBatteryObserver(this); }
+void BatteryManager::Shutdown() {
+  hal::UnregisterBatteryObserver(this);
+  if (sInstances) {
+    sInstances->RemoveElement(this);
+    if (sInstances->IsEmpty()) {
+      sInstances = nullptr;
+    }
+  }
+  mLastOverrideState.reset();
+}

 JSObject* BatteryManager::WrapObject(JSContext* aCx,
                                      JS::Handle<JSObject*> aGivenProto) {
@@ -53,6 +77,9 @@ JSObject* BatteryManager::WrapObject(JSContext* aCx,

 bool BatteryManager::Charging() const {
   MOZ_ASSERT(NS_IsMainThread());
+  if (auto value = MaskConfig::GetBool("battery:charging"); value.has_value()) {
+    return value.value();
+  }
   // For testing, unable to report the battery status information
   if (Preferences::GetBool("dom.battery.test.default", false)) {
     return true;
@@ -69,6 +96,9 @@ bool BatteryManager::Charging() const {

 double BatteryManager::DischargingTime() const {
   MOZ_ASSERT(NS_IsMainThread());
+  if (auto value = MaskConfig::GetDouble("battery:dischargingTime")) {
+    return value.value();
+  }
   // For testing, unable to report the battery status information
   if (Preferences::GetBool("dom.battery.test.default", false)) {
     return std::numeric_limits<double>::infinity();
@@ -86,6 +116,9 @@ double BatteryManager::DischargingTime() const {

 double BatteryManager::ChargingTime() const {
   MOZ_ASSERT(NS_IsMainThread());
+  if (auto value = MaskConfig::GetDouble("battery:chargingTime")) {
+    return value.value();
+  }
   // For testing, unable to report the battery status information
   if (Preferences::GetBool("dom.battery.test.default", false)) {
     return 0.0;
@@ -103,6 +136,9 @@ double BatteryManager::ChargingTime() const {

 double BatteryManager::Level() const {
   MOZ_ASSERT(NS_IsMainThread());
+  if (auto value = MaskConfig::GetDouble("battery:level")) {
+    return value.value();
+  }
   // For testing, unable to report the battery status information
   if (Preferences::GetBool("dom.battery.test.default")) {
     return 1.0;
@@ -111,6 +147,47 @@ double BatteryManager::Level() const {
   return mLevel;
 }

+BatteryManager::OverrideState BatteryManager::GetEffectiveOverrideState()
+    const {
+  OverrideState state;
+  state.mCharging = Charging();
+  state.mChargingTime = ChargingTime();
+  state.mDischargingTime = DischargingTime();
+  state.mLevel = Level();
+  return state;
+}
+
+void BatteryManager::UpdateLastOverrideState() {
+  mLastOverrideState.emplace(GetEffectiveOverrideState());
+}
+
+void BatteryManager::ApplyOverrides() {
+  MOZ_ASSERT(NS_IsMainThread());
+  OverrideState next = GetEffectiveOverrideState();
+
+  if (mLastOverrideState.isSome()) {
+    const OverrideState& previous = mLastOverrideState.ref();
+
+    if (previous.mCharging != next.mCharging) {
+      DispatchTrustedEvent(CHARGINGCHANGE_EVENT_NAME);
+    }
+
+    if (previous.mLevel != next.mLevel) {
+      DispatchTrustedEvent(LEVELCHANGE_EVENT_NAME);
+    }
+
+    if (previous.mChargingTime != next.mChargingTime) {
+      DispatchTrustedEvent(CHARGINGTIMECHANGE_EVENT_NAME);
+    }
+
+    if (previous.mDischargingTime != next.mDischargingTime) {
+      DispatchTrustedEvent(DISCHARGINGTIMECHANGE_EVENT_NAME);
+    }
+  }
+
+  mLastOverrideState.emplace(next);
+}
+
 void BatteryManager::UpdateFromBatteryInfo(
     const hal::BatteryInformation& aBatteryInfo) {
   mLevel = aBatteryInfo.level();
@@ -181,6 +258,28 @@ void BatteryManager::Notify(const hal::BatteryInformation& aBatteryInfo) {
     DispatchTrustedEvent(mCharging ? CHARGINGTIMECHANGE_EVENT_NAME
                                    : DISCHARGINGTIMECHANGE_EVENT_NAME);
   }
+
+  UpdateLastOverrideState();
+}
+
+/* static */
+void BatteryManager::NotifyOverrideChanged() {
+  if (!NS_IsMainThread()) {
+    Unused << NS_DispatchToMainThread(NS_NewRunnableFunction(
+        "BatteryOverrideChanged",
+        [] { BatteryManager::NotifyOverrideChanged(); }));
+    return;
+  }
+
+  if (!sInstances) {
+    return;
+  }
+
+  for (BatteryManager* manager : *sInstances) {
+    if (manager) {
+      manager->ApplyOverrides();
+    }
+  }
 }

 }  // namespace mozilla::dom::battery
diff --git a/dom/battery/BatteryManager.h b/dom/battery/BatteryManager.h
index 13f6dec52f..a92c0f5889 100644
--- a/dom/battery/BatteryManager.h
+++ b/dom/battery/BatteryManager.h
@@ -9,6 +9,9 @@

 #include "mozilla/DOMEventTargetHelper.h"
 #include "mozilla/HalBatteryInformation.h"
+#include "mozilla/Maybe.h"
+#include "mozilla/StaticPtr.h"
+#include "nsTArray.h"

 namespace mozilla {

@@ -21,11 +24,13 @@ namespace dom::battery {
 class BatteryManager final : public DOMEventTargetHelper,
                              public hal::BatteryObserver {
  public:
-  explicit BatteryManager(nsPIDOMWindowInner* aWindow);
+ explicit BatteryManager(nsPIDOMWindowInner* aWindow);

   void Init();
   void Shutdown();

+  static void NotifyOverrideChanged();
+
   // For IObserver.
   void Notify(const hal::BatteryInformation& aBatteryInfo) override;

@@ -51,12 +56,23 @@ class BatteryManager final : public DOMEventTargetHelper,
   IMPL_EVENT_HANDLER(levelchange)

  private:
+  struct OverrideState {
+    bool mCharging;
+    double mChargingTime;
+    double mDischargingTime;
+    double mLevel;
+  };
+
   /**
    * Update the battery information stored in the battery manager object using
    * a battery information object.
    */
   void UpdateFromBatteryInfo(const hal::BatteryInformation& aBatteryInfo);

+  OverrideState GetEffectiveOverrideState() const;
+  void UpdateLastOverrideState();
+  void ApplyOverrides();
+
   /**
    * Represents the battery level, ranging from 0.0 (dead or removed?)
    * to 1.0 (fully charged)
@@ -68,6 +84,9 @@ class BatteryManager final : public DOMEventTargetHelper,
    * current battery status (charging or not).
    */
   double mRemainingTime;
+  mozilla::Maybe<OverrideState> mLastOverrideState;
+
+  static mozilla::StaticAutoPtr<nsTArray<BatteryManager*>> sInstances;
 };

 }  // namespace dom::battery
diff --git a/dom/battery/moz.build b/dom/battery/moz.build
index 3a90c93c01..ce6881a758 100644
--- a/dom/battery/moz.build
+++ b/dom/battery/moz.build
@@ -21,3 +21,6 @@ FINAL_LIBRARY = "xul"

 MOCHITEST_CHROME_MANIFESTS += ["test/chrome.toml"]
 MOCHITEST_MANIFESTS += ["test/mochitest.toml"]
+
+# DOM Mask
+LOCAL_INCLUDES += ["/camoucfg"]
diff --git a/dom/chrome-webidl/ChromeUtils.webidl b/dom/chrome-webidl/ChromeUtils.webidl
index d90b4c8757..3ffce38f3a 100644
--- a/dom/chrome-webidl/ChromeUtils.webidl
+++ b/dom/chrome-webidl/ChromeUtils.webidl
@@ -54,6 +54,14 @@ dictionary ProfilerMarkerOptions {
   unsigned long long innerWindowId = 0;
 };

+dictionary CamouBatteryOverride {
+  boolean? enabled;
+  boolean? charging;
+  unrestricted double? chargingTime;
+  unrestricted double? dischargingTime;
+  unrestricted double? level;
+};
+
 dictionary InteractionData {
   unsigned long interactionCount = 0;
   unsigned long interactionTimeInMilliseconds = 0;
@@ -781,6 +789,13 @@ partial namespace ChromeUtils {
    */
   boolean isDarkBackground(Element element);

+  /**
+   * Camoufox debug commands
+   */
+  undefined camouDebug(DOMString varName);
+
+  boolean isCamouDebug();
+
   /**
    * Starts the JSOracle process for ORB JavaScript validation, if it hasn't started already.
    */
diff --git a/dom/webidl/Navigator.webidl b/dom/webidl/Navigator.webidl
index 1fd32ac068..3bd4db24d0 100644
--- a/dom/webidl/Navigator.webidl
+++ b/dom/webidl/Navigator.webidl
@@ -134,8 +134,8 @@ Navigator includes NavigatorGeolocation;

 // http://www.w3.org/TR/battery-status/#navigatorbattery-interface
 partial interface Navigator {
-  // ChromeOnly to prevent web content from fingerprinting users' batteries.
-  [Throws, ChromeOnly, Pref="dom.battery.enabled"]
+  // Controlled via dom.battery.enabled and Camoufox mask configuration.
+  [Throws, Pref="dom.battery.enabled"]
   Promise<BatteryManager> getBattery();
 };

diff --git a/dom/base/nsPluginArray.h b/dom/base/nsPluginArray.h
index 71df3d1..7d6f988 100644
--- a/dom/base/nsPluginArray.h
+++ b/dom/base/nsPluginArray.h
@@ -7,7 +7,6 @@
 #ifndef nsPluginArray_h___
 #define nsPluginArray_h___
 
-#include "mozilla/Array.h"
 #include "nsCOMPtr.h"
 #include "nsString.h"
 #include "nsTArray.h"
@@ -39,7 +38,7 @@ class nsPluginArray final : public nsSupportsWeakReference,
   nsMimeTypeArray* MimeTypeArray() { return mMimeTypeArray; }
 
   // PluginArray WebIDL methods
-  uint32_t Length() { return ForceNoPlugins() ? 0 : std::size(mPlugins); }
+  uint32_t Length() const { return mPlugins.Length(); }
 
   nsPluginElement* Item(uint32_t aIndex) {
     bool unused;
@@ -62,11 +61,9 @@ class nsPluginArray final : public nsSupportsWeakReference,
  private:
   virtual ~nsPluginArray();
 
-  bool ForceNoPlugins();
-
   RefPtr<nsMimeTypeArray> mMimeTypeArray;
   nsCOMPtr<nsPIDOMWindowInner> mWindow;
-  mozilla::Array<RefPtr<nsPluginElement>, 5> mPlugins;
+  nsTArray<RefPtr<nsPluginElement>> mPlugins;
 };
 
 /**
@@ -79,7 +76,9 @@ class nsPluginElement final : public nsISupports, public nsWrapperCache {
   NS_DECL_CYCLE_COLLECTION_WRAPPERCACHE_CLASS(nsPluginElement)
 
   explicit nsPluginElement(nsPluginArray* aPluginArray,
-                           nsPIDOMWindowInner* aWindow, const nsAString& aName);
+                           nsPIDOMWindowInner* aWindow, const nsAString& aName,
+                           const nsAString& aDescription,
+                           const nsAString& aFilename);
 
   nsPluginArray* GetParentObject() const;
 
@@ -87,9 +86,9 @@ class nsPluginElement final : public nsISupports, public nsWrapperCache {
                                JS::Handle<JSObject*> aGivenProto) override;
 
   // Plugin WebIDL methods
-  void GetDescription(nsString& retval) const { retval = kDescription; }
+  void GetDescription(nsString& retval) const { retval = mDescription; }
 
-  void GetFilename(nsString& retval) const { retval = kFilename; }
+  void GetFilename(nsString& retval) const { retval = mFilename; }
 
   void GetName(nsString& retval) const { retval = mName; }
   const nsString& Name() const { return mName; }
@@ -112,15 +111,11 @@ class nsPluginElement final : public nsISupports, public nsWrapperCache {
 
   void GetSupportedNames(nsTArray<nsString>& retval);
 
+  void AddMimeType(nsMimeType* aMimeType);
+
  protected:
   virtual ~nsPluginElement() = default;
 
-  nsMimeTypeArray* MimeTypeArray() { return mPluginArray->MimeTypeArray(); }
-
-  static constexpr nsLiteralString kDescription =
-      u"Portable Document Format"_ns;
-  static constexpr nsLiteralString kFilename = u"internal-pdf-viewer"_ns;
-
   // Note that this creates an explicit reference cycle:
   //
   // nsPluginElement -> nsPluginArray -> nsPluginElement
@@ -129,6 +124,9 @@ class nsPluginElement final : public nsISupports, public nsWrapperCache {
   RefPtr<nsPluginArray> mPluginArray;
   nsCOMPtr<nsPIDOMWindowInner> mWindow;
   nsString mName;
+  nsString mDescription;
+  nsString mFilename;
+  nsTArray<RefPtr<nsMimeType>> mMimeTypes;
 };
 
 #endif /* nsPluginArray_h___ */
diff --git a/dom/base/nsMimeTypeArray.cpp b/dom/base/nsMimeTypeArray.cpp
index 34f1f16..4e15cde 100644
--- a/dom/base/nsMimeTypeArray.cpp
+++ b/dom/base/nsMimeTypeArray.cpp
@@ -6,7 +6,6 @@
 
 #include "nsMimeTypeArray.h"
 
-#include "mozilla/StaticPrefs_pdfjs.h"
 #include "mozilla/dom/MimeTypeArrayBinding.h"
 #include "mozilla/dom/MimeTypeBinding.h"
 #include "nsContentUtils.h"
@@ -22,12 +21,11 @@ NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsMimeTypeArray)
   NS_INTERFACE_MAP_ENTRY(nsISupports)
 NS_INTERFACE_MAP_END
 
-NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(nsMimeTypeArray, mWindow, mMimeTypes[0],
-                                      mMimeTypes[1])
+NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(nsMimeTypeArray, mWindow, mMimeTypes)
 
 nsMimeTypeArray::nsMimeTypeArray(
     nsPIDOMWindowInner* aWindow,
-    const mozilla::Array<RefPtr<nsMimeType>, 2>& aMimeTypes)
+    const nsTArray<RefPtr<nsMimeType>>& aMimeTypes)
     : mWindow(aWindow), mMimeTypes(aMimeTypes) {}
 
 nsMimeTypeArray::~nsMimeTypeArray() = default;
@@ -43,7 +41,7 @@ nsPIDOMWindowInner* nsMimeTypeArray::GetParentObject() const {
 }
 
 nsMimeType* nsMimeTypeArray::IndexedGetter(uint32_t aIndex, bool& aFound) {
-  if (!ForceNoPlugins() && aIndex < std::size(mMimeTypes)) {
+  if (aIndex < mMimeTypes.Length()) {
     aFound = true;
     return mMimeTypes[aIndex];
   }
@@ -53,11 +51,6 @@ nsMimeType* nsMimeTypeArray::IndexedGetter(uint32_t aIndex, bool& aFound) {
 }
 
 nsMimeType* nsMimeTypeArray::NamedGetter(const nsAString& aName, bool& aFound) {
-  if (ForceNoPlugins()) {
-    aFound = false;
-    return nullptr;
-  }
-
   for (const auto& mimeType : mMimeTypes) {
     if (mimeType->Name().Equals(aName)) {
       aFound = true;
@@ -70,21 +63,20 @@ nsMimeType* nsMimeTypeArray::NamedGetter(const nsAString& aName, bool& aFound) {
 }
 
 void nsMimeTypeArray::GetSupportedNames(nsTArray<nsString>& retval) {
-  if (ForceNoPlugins()) {
-    return;
-  }
-
   for (auto& mimeType : mMimeTypes) {
     retval.AppendElement(mimeType->Name());
   }
 }
 
-bool nsMimeTypeArray::ForceNoPlugins() { return StaticPrefs::pdfjs_disabled(); }
-
 NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(nsMimeType, mPluginElement)
 
-nsMimeType::nsMimeType(nsPluginElement* aPluginElement, const nsAString& aName)
-    : mPluginElement(aPluginElement), mName(aName) {
+nsMimeType::nsMimeType(nsPluginElement* aPluginElement, const nsAString& aName,
+                       const nsAString& aDescription,
+                       const nsAString& aSuffixes)
+    : mPluginElement(aPluginElement),
+      mName(aName),
+      mDescription(aDescription),
+      mSuffixes(aSuffixes) {
   MOZ_ASSERT(aPluginElement);
 }

diff --git a/dom/base/nsMimeTypeArray.h b/dom/base/nsMimeTypeArray.h
index 4e2f16b..d82563a 100644
--- a/dom/base/nsMimeTypeArray.h
+++ b/dom/base/nsMimeTypeArray.h
@@ -25,7 +25,7 @@ class nsPluginElement;
 class nsMimeTypeArray final : public nsISupports, public nsWrapperCache {
  public:
   nsMimeTypeArray(nsPIDOMWindowInner* aWindow,
-                  const mozilla::Array<RefPtr<nsMimeType>, 2>& aMimeTypes);
+                  const nsTArray<RefPtr<nsMimeType>>& aMimeTypes);
 
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_CYCLE_COLLECTION_WRAPPERCACHE_CLASS(nsMimeTypeArray)
@@ -35,7 +35,7 @@ class nsMimeTypeArray final : public nsISupports, public nsWrapperCache {
                                JS::Handle<JSObject*> aGivenProto) override;
 
   // MimeTypeArray WebIDL methods
-  uint32_t Length() { return ForceNoPlugins() ? 0 : std::size(mMimeTypes); }
+  uint32_t Length() const { return mMimeTypes.Length(); }
 
   nsMimeType* Item(uint32_t aIndex) {
     bool unused;
@@ -56,10 +56,8 @@ class nsMimeTypeArray final : public nsISupports, public nsWrapperCache {
  protected:
   virtual ~nsMimeTypeArray();
 
-  bool ForceNoPlugins();
-
   nsCOMPtr<nsPIDOMWindowInner> mWindow;
-  mozilla::Array<RefPtr<nsMimeType>, 2> mMimeTypes;
+  nsTArray<RefPtr<nsMimeType>> mMimeTypes;
 };
 
 /**
@@ -71,7 +69,8 @@ class nsMimeType final : public nsWrapperCache {
   NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING(nsMimeType)
   NS_DECL_CYCLE_COLLECTION_NATIVE_WRAPPERCACHE_CLASS(nsMimeType)
 
-  nsMimeType(nsPluginElement* aPluginElement, const nsAString& aName);
+  nsMimeType(nsPluginElement* aPluginElement, const nsAString& aName,
+             const nsAString& aDescription, const nsAString& aSuffixes);
 
   nsPluginElement* GetParentObject() const { return mPluginElement; }
 
@@ -80,13 +79,13 @@ class nsMimeType final : public nsWrapperCache {
 
   // MimeType WebIDL methods
   void GetDescription(mozilla::dom::DOMString& retval) const {
-    retval.SetKnownLiveString(kMimeDescription);
+    retval.AsAString() = mDescription;
   }
 
   already_AddRefed<nsPluginElement> EnabledPlugin() const;
 
   void GetSuffixes(mozilla::dom::DOMString& retval) const {
-    retval.SetKnownLiveString(kMimeSuffix);
+    retval.AsAString() = mSuffixes;
   }
 
   void GetType(nsString& retval) const { retval = mName; }
@@ -95,10 +94,6 @@ class nsMimeType final : public nsWrapperCache {
  protected:
   virtual ~nsMimeType();
 
-  static constexpr nsLiteralString kMimeDescription =
-      u"Portable Document Format"_ns;
-  static constexpr nsLiteralString kMimeSuffix = u"pdf"_ns;
-
   // Note that this creates an explicit reference cycle:
   //
   // nsMimeType -> nsPluginElement -> nsPluginArray ->
@@ -107,6 +102,8 @@ class nsMimeType final : public nsWrapperCache {
   // We rely on the cycle collector to break this cycle.
   RefPtr<nsPluginElement> mPluginElement;
   nsString mName;
+  nsString mDescription;
+  nsString mSuffixes;
 };
 
 #endif /* nsMimeTypeArray_h___ */
diff --git a/dom/base/nsPluginArray.cpp b/dom/base/nsPluginArray.cpp
index 8807ef2..ebadf88 100644
--- a/dom/base/nsPluginArray.cpp
+++ b/dom/base/nsPluginArray.cpp
@@ -6,12 +6,14 @@
 
 #include "nsPluginArray.h"
 
+#include "MaskConfig.hpp"
 #include "mozilla/StaticPrefs_pdfjs.h"
 #include "mozilla/dom/PluginArrayBinding.h"
 #include "mozilla/dom/PluginBinding.h"
 #include "nsContentUtils.h"
 #include "nsMimeTypeArray.h"
 #include "nsPIDOMWindow.h"
+#include "nsReadableUtils.h"
 
 using namespace mozilla;
 using namespace mozilla::dom;
@@ -27,22 +29,163 @@ static const nsLiteralString kMainPluginName = u"PDF Viewer"_ns;
 static const nsLiteralString kExtraPluginNames[] = {
     u"Chrome PDF Viewer"_ns, u"Chromium PDF Viewer"_ns,
     u"Microsoft Edge PDF Viewer"_ns, u"WebKit built-in PDF"_ns};
-static const nsLiteralString kMimeTypeNames[] = {u"application/pdf"_ns,
-                                                 u"text/pdf"_ns};
+static const nsLiteralString kDefaultPluginDescription =
+    u"Portable Document Format"_ns;
+static const nsLiteralString kDefaultPluginFilename =
+    u"internal-pdf-viewer"_ns;
+static const nsLiteralString kDefaultMimeDescription =
+    u"Portable Document Format"_ns;
+static const nsLiteralString kDefaultMimeSuffix = u"pdf"_ns;
+
+static void AppendSharedMimeTypes(
+    nsPluginElement* aPlugin,
+    const nsTArray<RefPtr<nsMimeType>>& aMimeTypes) {
+  for (auto const& mime : aMimeTypes) {
+    aPlugin->AddMimeType(mime);
+  }
+}
+
+static RefPtr<nsMimeType> CreateMimeType(nsPluginElement* aPlugin,
+                                         const nsAString& aType,
+                                         const nsAString& aDescription,
+                                         const nsAString& aSuffix) {
+  return MakeRefPtr<nsMimeType>(aPlugin, aType, aDescription, aSuffix);
+}
 
 nsPluginArray::nsPluginArray(nsPIDOMWindowInner* aWindow) : mWindow(aWindow) {
-  // Create the hard-coded PDF plugin types that share MIME type arrays.
-  mPlugins[0] = MakeRefPtr<nsPluginElement>(this, aWindow, kMainPluginName);
+  nsTArray<RefPtr<nsMimeType>> globalMimeTypes;
+  bool appliedOverride = false;
 
-  mozilla::Array<RefPtr<nsMimeType>, 2> mimeTypes;
-  for (uint32_t i = 0; i < std::size(kMimeTypeNames); ++i) {
-    mimeTypes[i] = MakeRefPtr<nsMimeType>(mPlugins[0], kMimeTypeNames[i]);
+  if (auto plugins = MaskConfig::GetJsonValue("navigator.plugins")) {
+    appliedOverride = true;
+    if (plugins->is_array()) {
+      for (const auto& pluginEntry : *plugins) {
+        if (!pluginEntry.is_object()) {
+          continue;
+        }
+        auto nameIt = pluginEntry.find("name");
+        if (nameIt == pluginEntry.end() || !nameIt->is_string()) {
+          continue;
+        }
+        nsString name =
+            NS_ConvertUTF8toUTF16(nameIt->get<std::string>().c_str());
+        nsString description = kDefaultPluginDescription;
+        nsString filename = kDefaultPluginFilename;
+
+        if (auto descIt = pluginEntry.find("description");
+            descIt != pluginEntry.end() && descIt->is_string()) {
+          description.Assign(
+              NS_ConvertUTF8toUTF16(descIt->get<std::string>().c_str()));
+        }
+        if (auto fileIt = pluginEntry.find("filename");
+            fileIt != pluginEntry.end() && fileIt->is_string()) {
+          filename.Assign(
+              NS_ConvertUTF8toUTF16(fileIt->get<std::string>().c_str()));
+        }
+
+        RefPtr<nsPluginElement> plugin =
+            MakeRefPtr<nsPluginElement>(this, aWindow, name, description,
+                                        filename);
+
+        bool hasMimeTypes = false;
+        if (auto mimeArrayIt = pluginEntry.find("mimeTypes");
+            mimeArrayIt != pluginEntry.end() && mimeArrayIt->is_array()) {
+          for (const auto& mimeEntry : *mimeArrayIt) {
+            if (mimeEntry.is_null()) {
+              continue;
+            }
+
+            nsString type;
+            nsString mimeDescription = kDefaultMimeDescription;
+            nsString suffixes = kDefaultMimeSuffix;
+
+            if (mimeEntry.is_string()) {
+              type.Assign(
+                  NS_ConvertUTF8toUTF16(mimeEntry.get<std::string>().c_str()));
+            } else if (mimeEntry.is_object()) {
+              auto typeIt = mimeEntry.find("type");
+              if (typeIt == mimeEntry.end() || !typeIt->is_string()) {
+                continue;
+              }
+              type.Assign(
+                  NS_ConvertUTF8toUTF16(typeIt->get<std::string>().c_str()));
+
+              if (auto descIt = mimeEntry.find("description");
+                  descIt != mimeEntry.end() && descIt->is_string()) {
+                mimeDescription.Assign(NS_ConvertUTF8toUTF16(
+                    descIt->get<std::string>().c_str()));
+              }
+
+              if (auto suffixIt = mimeEntry.find("suffixes");
+                  suffixIt != mimeEntry.end() && suffixIt->is_string()) {
+                suffixes.Assign(
+                    NS_ConvertUTF8toUTF16(suffixIt->get<std::string>().c_str()));
+              }
+            } else {
+              continue;
+            }
+
+            RefPtr<nsMimeType> sharedMime;
+            for (const auto& existing : globalMimeTypes) {
+              if (existing->Name().Equals(type)) {
+                sharedMime = existing;
+                break;
+              }
+            }
+
+            if (!sharedMime) {
+              sharedMime =
+                  CreateMimeType(plugin, type, mimeDescription, suffixes);
+              globalMimeTypes.AppendElement(sharedMime);
+            }
+            plugin->AddMimeType(sharedMime);
+            hasMimeTypes = true;
+          }
+        }
+
+        if (!hasMimeTypes && !globalMimeTypes.IsEmpty()) {
+          AppendSharedMimeTypes(plugin, globalMimeTypes);
+        }
+
+        mPlugins.AppendElement(plugin);
+      }
+    }
+  }
+
+  if (!appliedOverride) {
+    if (!StaticPrefs::pdfjs_disabled()) {
+      RefPtr<nsPluginElement> mainPlugin =
+          MakeRefPtr<nsPluginElement>(this, aWindow, kMainPluginName,
+                                      kDefaultPluginDescription,
+                                      kDefaultPluginFilename);
+      RefPtr<nsMimeType> applicationPdf = CreateMimeType(
+          mainPlugin, u"application/pdf"_ns, kDefaultMimeDescription,
+          kDefaultMimeSuffix);
+      RefPtr<nsMimeType> textPdf = CreateMimeType(
+          mainPlugin, u"text/pdf"_ns, kDefaultMimeDescription,
+          kDefaultMimeSuffix);
+
+      mainPlugin->AddMimeType(applicationPdf);
+      mainPlugin->AddMimeType(textPdf);
+
+      globalMimeTypes.AppendElement(applicationPdf);
+      globalMimeTypes.AppendElement(textPdf);
+      mPlugins.AppendElement(mainPlugin);
+
+      for (const auto& extraName : kExtraPluginNames) {
+        RefPtr<nsPluginElement> extraPlugin =
+            MakeRefPtr<nsPluginElement>(this, aWindow, extraName,
+                                        kDefaultPluginDescription,
+                                        kDefaultPluginFilename);
+        AppendSharedMimeTypes(extraPlugin, globalMimeTypes);
+        mPlugins.AppendElement(extraPlugin);
+      }
+    }
   }
-  mMimeTypeArray = MakeRefPtr<nsMimeTypeArray>(aWindow, mimeTypes);
 
-  for (uint32_t i = 0; i < std::size(kExtraPluginNames); ++i) {
-    mPlugins[i + 1] =
-        MakeRefPtr<nsPluginElement>(this, aWindow, kExtraPluginNames[i]);
+  if (!mMimeTypeArray) {
+    mMimeTypeArray =
+        MakeRefPtr<nsMimeTypeArray>(aWindow, globalMimeTypes);
   }
 }
 
@@ -59,7 +202,7 @@ JSObject* nsPluginArray::WrapObject(JSContext* aCx,
 }
 
 nsPluginElement* nsPluginArray::IndexedGetter(uint32_t aIndex, bool& aFound) {
-  if (!ForceNoPlugins() && aIndex < std::size(mPlugins)) {
+  if (aIndex < mPlugins.Length()) {
     aFound = true;
     return mPlugins[aIndex];
   }
@@ -70,11 +213,6 @@ nsPluginElement* nsPluginArray::IndexedGetter(uint32_t aIndex, bool& aFound) {
 
 nsPluginElement* nsPluginArray::NamedGetter(const nsAString& aName,
                                             bool& aFound) {
-  if (ForceNoPlugins()) {
-    aFound = false;
-    return nullptr;
-  }
-
   for (const auto& plugin : mPlugins) {
     if (plugin->Name().Equals(aName)) {
       aFound = true;
@@ -87,17 +225,11 @@ nsPluginElement* nsPluginArray::NamedGetter(const nsAString& aName,
 }
 
 void nsPluginArray::GetSupportedNames(nsTArray<nsString>& aRetval) {
-  if (ForceNoPlugins()) {
-    return;
-  }
-
   for (auto& plugin : mPlugins) {
     aRetval.AppendElement(plugin->Name());
   }
 }
 
-bool nsPluginArray::ForceNoPlugins() { return StaticPrefs::pdfjs_disabled(); }
-
 NS_IMPL_CYCLE_COLLECTING_ADDREF(nsPluginArray)
 NS_IMPL_CYCLE_COLLECTING_RELEASE(nsPluginArray)
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsPluginArray)
@@ -106,17 +238,21 @@ NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsPluginArray)
   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
 NS_INTERFACE_MAP_END
 
-NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE_WEAK(nsPluginArray, mPlugins[0],
-                                           mPlugins[1], mPlugins[2],
-                                           mPlugins[3], mPlugins[4],
+NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE_WEAK(nsPluginArray, mPlugins,
                                            mMimeTypeArray, mWindow)
 
 // nsPluginElement implementation.
 
 nsPluginElement::nsPluginElement(nsPluginArray* aPluginArray,
                                  nsPIDOMWindowInner* aWindow,
-                                 const nsAString& aName)
-    : mPluginArray(aPluginArray), mWindow(aWindow), mName(aName) {}
+                                 const nsAString& aName,
+                                 const nsAString& aDescription,
+                                 const nsAString& aFilename)
+    : mPluginArray(aPluginArray),
+      mWindow(aWindow),
+      mName(aName),
+      mDescription(aDescription),
+      mFilename(aFilename) {}
 
 nsPluginArray* nsPluginElement::GetParentObject() const { return mPluginArray; }
 
@@ -126,18 +262,37 @@ JSObject* nsPluginElement::WrapObject(JSContext* aCx,
 }
 
 nsMimeType* nsPluginElement::IndexedGetter(uint32_t aIndex, bool& aFound) {
-  return MimeTypeArray()->IndexedGetter(aIndex, aFound);
+  if (aIndex < mMimeTypes.Length()) {
+    aFound = true;
+    return mMimeTypes[aIndex];
+  }
+  aFound = false;
+  return nullptr;
 }
 
 nsMimeType* nsPluginElement::NamedGetter(const nsAString& aName, bool& aFound) {
-  return MimeTypeArray()->NamedGetter(aName, aFound);
+  for (const auto& mime : mMimeTypes) {
+    if (mime->Name().Equals(aName)) {
+      aFound = true;
+      return mime;
+    }
+  }
+  aFound = false;
+  return nullptr;
 }
 
 void nsPluginElement::GetSupportedNames(nsTArray<nsString>& retval) {
-  return MimeTypeArray()->GetSupportedNames(retval);
+  for (auto& mime : mMimeTypes) {
+    retval.AppendElement(mime->Name());
+  }
 }
 
-uint32_t nsPluginElement::Length() { return MimeTypeArray()->Length(); }
+uint32_t nsPluginElement::Length() { return mMimeTypes.Length(); }
+
+void nsPluginElement::AddMimeType(nsMimeType* aMimeType) {
+  MOZ_ASSERT(aMimeType);
+  mMimeTypes.AppendElement(aMimeType);
+}
 
 NS_IMPL_CYCLE_COLLECTING_ADDREF(nsPluginElement)
 NS_IMPL_CYCLE_COLLECTING_RELEASE(nsPluginElement)
@@ -146,4 +301,5 @@ NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsPluginElement)
   NS_INTERFACE_MAP_ENTRY(nsISupports)
 NS_INTERFACE_MAP_END
 
-NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(nsPluginElement, mWindow, mPluginArray)
+NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(nsPluginElement, mWindow, mPluginArray,
+                                      mMimeTypes)
